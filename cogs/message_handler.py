import random

import discord
from discord.ext import commands
import asyncio
from agents.llm_agent import LLMAgent

class MessageHandler(commands.Cog):
    def __init__(self, bot, webhook_manager, config):
        super().__init__()  # Initialize the superclass
        self.bot = bot
        self.webhook_manager = webhook_manager
        self.config = config
        self.agents = {}
        self.agents_lock = asyncio.Lock()

    @commands.Cog.listener()
    async def on_ready(self):
        print('MessageHandler Cog is ready.')

    @commands.Cog.listener()
    async def on_message(self, message):
        # Prevent the bot from responding to its own messages or webhooks
        if message.author == self.bot.user or isinstance(message.author, discord.Webhook):
            return

        if (self.config.KEYWORD.lower() in message.content.lower()) and ("`" + self.config.KEYWORD.lower() + "`" not in message.content.lower()):
            print(f'Keyword "{self.config.KEYWORD}" detected in channel {message.channel.name} (ID: {message.channel.id}).')
            await self.handle_keyword(message)

        await self.bot.process_commands(message)

    async def handle_keyword(self, message):
        """
        Handles the keyword detection by deleting the user's message,
        replacing it with 'Generating...', and interacting with the LLM agent.
        """
        try:
            # Delete the user's original message
            await message.delete()
            print(f'Deleted message from {message.author.display_name} in channel {message.channel.name}.')

            # Get the channel object
            # channel = self.bot.get_channel(message.channel_id)
            # if not channel:
            #     print(f"Channel with ID {message.channel_id} not found.")
            #     return

            webhooks = list(self.webhook_manager.webhook_objects.keys())
            # randomize the webhook to use
            max_index = len(webhooks) - 1
            index = random.randint(0, max_index)
            webhook_name = webhooks[index]

            # Move the webhook to the target channel if not already there

            webhook = await self.webhook_manager.move_webhook(webhook_name, message.channel)

            if not webhook:
                print("Failed to move webhook for the replacement.")
                return

            # Send 'Generating...' via webhook, capture the message object
            generating_content = "Generating..."
            reversed_username = message.author.display_name + "[oblique]"
            sent_message = await self.webhook_manager.send_via_webhook(
                name=webhook_name,
                content=generating_content,
                username=reversed_username,
                avatar_url=message.author.display_avatar.url if message.author.display_avatar else None
            )
            if not sent_message:
                print("Failed to send 'Generating...' message via webhook.")
                return
            print(f"Sent 'Generating...' message via webhook '{webhook}' with message ID {sent_message.id}.")

            # Prepare data for the LLM agent
            data = {
                'message': message,
                'generating_message_id': sent_message.id,
                'channel_id': message.channel.id,
                'username': message.author.display_name,
                'webhook': webhook_name
            }

            # Interact with the LLM agent (stateful)
            agent = await self.get_or_create_agent(message.author.id)
            await agent.enqueue_message(data)

        except discord.errors.NotFound:
            print("The message or webhook was not found.")
        except discord.errors.Forbidden:
            print("Missing permissions to delete messages or manage webhooks.")
        except Exception as e:
            print(f'Error handling keyword: {e}')
            # print stack trace
            import traceback
            traceback.print_exc()

    async def get_or_create_agent(self, user_id):
        """
        Retrieves an existing LLM agent for the user or creates a new one.

        Args:
            user_id (int): The Discord user ID.

        Returns:
            LLMAgent: The stateful LLM agent instance.
        """
        async with self.agents_lock:
            if user_id not in self.agents:
                # Define the callback function to handle the LLM's response
                async def llm_callback(data, replacement_text):
                    """
                    Callback function to handle the LLM's response.

                    Args:
                        data (dict): Data containing 'generating_message_id', 'channel_id', 'username'.
                        replacement_text (str): The text generated by the LLM.
                    """
                    try:
                        # Extract necessary information
                        generating_message_id = data['generating_message_id']
                        webhook_name = data['webhook']
                        channel_id = data['channel_id']
                        username = data['username']

                        # Get the channel object
                        channel = self.bot.get_channel(channel_id)
                        if not channel:
                            print(f"Channel with ID {channel_id} not found.")
                            return


                        # Edit the 'Generating...' message with the LLM-generated replacement
                        await self.webhook_manager.edit_via_webhook(
                            name=webhook_name,
                            message_id=generating_message_id,
                            new_content=replacement_text
                        )
                        print(f"Sent LLM-generated replacement for user '{username}'.")
                    except Exception as e:
                        print(f"Error sending LLM-generated replacement: {e}")

                agent = LLMAgent(name=f"Agent_{user_id}", config=self.config, callback=llm_callback)
                self.agents[user_id] = agent
                print(f"Created new LLM agent for user ID {user_id}.")
            return self.agents[user_id]

    async def cog_unload(self):
        """
        Clean up tasks when the Cog is unloaded.
        """
        async with self.agents_lock:
            for agent in self.agents.values():
                await agent.shutdown()
            self.agents.clear()
        print("MessageHandler Cog has been unloaded and agents have been shut down.")

# Asynchronous setup function for the Cog
async def setup(bot):
    await bot.add_cog(MessageHandler(bot, bot.get_cog('WebhookManager'), bot.config))
